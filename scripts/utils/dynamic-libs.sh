#!/usr/bin/env bash

usage() {
	local old_xtrace
	old_xtrace="$(shopt -po xtrace || :)"
	set +o xtrace
	echo "${script_name} - List dynamic library dependencies." >&2
	echo "Usage: ${script_name} [flags] directory" >&2
	echo "Option flags:" >&2
	echo "  -h --help    - Show this help and exit." >&2
	echo "  -v --verbose - Verbose execution." >&2
	eval "${old_xtrace}"
}

process_opts() {
	local short_opts="hv"
	local long_opts="help,verbose"

	local opts
	opts=$(getopt --options ${short_opts} --long ${long_opts} -n "${script_name}" -- "$@")

	eval set -- "${opts}"

	while true ; do
		#echo "${FUNCNAME[0]}: @${1}@ @${2}@"
		case "${1}" in
		-h | --help)
			usage=1
			shift
			;;
		-v | --verbose)
			set -x
			#verbose=1
			shift
			;;
		--)
			shift
			src_dir="${1}"
			if [[ ${2} ]]; then
				shift
				set +o xtrace
				echo "${script_name}: ERROR: Got extra args: '${*}'" >&2
				usage
				exit 1
			fi
			break
			;;
		*)
			echo "${script_name}: ERROR: Internal opts: '${*}'" >&2
			exit 1
			;;
		esac
	done
}

on_exit() {
	local result=${1}

	set +x
	echo "${script_name}: Done : ${result}." >&2
}

#===============================================================================
export PS4='\[\033[0;33m\]+ ${BASH_SOURCE##*/}:${LINENO}:(${FUNCNAME[0]:-"?"}): \[\033[0;37m\]'
script_name="${0##*/}"

SCRIPTS_TOP="${SCRIPTS_TOP:-$(cd "${BASH_SOURCE%/*}" && pwd)}"

readelf="${readelf:-readelf}"

trap "on_exit 'failed'" EXIT
set -e

process_opts "${@}"

if [[ ${usage} ]]; then
	usage
	trap - EXIT
	exit 0
fi

if [[ ! -d "${src_dir}" ]]; then
	echo "${script_name}: ERROR: Source directory not found: '${src_dir}'" >&2
	usage
	exit 1
fi

src_dir="$(realpath "${src_dir}")"

readarray files < <(find "${src_dir}" -type f | sort)

echo "Generated by ${script_name}"
date +%Y.%m.%d-%H.%M.%S
echo "https://github.com/glevand/tdd-project"
echo ''
echo "Source directory = '${src_dir}'"

lib_regex="^[^(]+\(NEEDED\) *(Shared library: .+)$"
rpath_regex="^[^(]+\(RPATH\) *(Library rpath: .+)$"

for f in "${files[@]}"; do
	f="${f//[$'\t\r\n ']}"
	if data="$("${readelf}" -d "${f}" 2>/dev/null)"; then
		echo "----------------------------"
		echo "'${f}'"
		echo ""
		while read -r line; do
			#echo "line = '${line}'"
			if [[ "${line}" =~ ${lib_regex} ]]; then
				#echo "match = '${BASH_REMATCH[0]}'"
				echo "${BASH_REMATCH[1]}"
			elif [[ "${line}" =~ ${rpath_regex} ]]; then
				#echo "match = '${BASH_REMATCH[0]}'"
				echo ""
				echo "${BASH_REMATCH[1]}"
			fi
		done< <(echo "${data}")
		echo ""
	fi
done

trap "on_exit 'Success'" EXIT
exit 0
